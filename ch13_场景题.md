13、淘宝有20亿个商品信息，每个商品信息包括卖家信息和价格，设计一种方法找到价格最高的100种商品的信息？如果系统要经常找到价格最高的100种商品，那么怎么优化？

构建一个小顶堆，前一百个商品信息随意插入，一百之后的商品如果大于堆顶元素则移除堆顶元素，插入该商品，一直做下去，总的时间复杂度为o(nlogk),其中n=20亿,k=100

16、日志文件10亿条，每条记录 用户账号 上线时间 下线时间。时间从0---86400s，最小时间复杂度和最小空间复杂度  得出每一秒在线人数的统计情况?

构建一个哈希表，86401个槽（对应0---86400）初始值全部为0，开始读取日志文件，分析某条记录中某个用户的上线下线时间段，然后让该段对应的hashmap槽位自增1，一次类推即可统计出每一秒在线人数。
再之也可以将这10亿条数据分散开，开启多个线程或者多态机器完成前面的步骤，最后汇总。

19、定时器为什么要采用最小堆

定时器是一个常见的应用场景，它需要在指定的时间点触发某个事件或者执行某个任务。
在实现定时器时，我们需要一个数据结构来存储所有的定时器，并且能够快速地找到最近要触发的定时器。最小堆是一个常用的数据结构，用于实现定时器。
最小堆是一种二叉树结构，每个节点的值都小于或等于其子节点的值。
在定时器中，我们可以将每个定时器的触发时间作为节点的值，并将所有定时器组成一个最小堆。
这样，堆顶节点就是最近要触发的定时器，我们只需要将堆顶节点取出来，就可以得到最近要触发的定时器的信息。
最小堆的插入和删除操作的时间复杂度都是 O(log n)，其中 n 是堆中节点的数量。
这意味着我们可以在 O(log n) 的时间内插入和删除定时器。同时，由于最小堆的特性，我们可以保证堆顶节点是最小的，因此可以快速找到最近要触发的定时器。
因此，最小堆是实现定时器的一个非常有效的数据结构。它兼具高效性和准确性，可以满足大多数定时器的需求。

21、定时器补充：

除了小根堆，还有其他数据结构可以用于实现定时器，以下是一些常见的方法：

1. 链表：将所有定时器按照时间顺序插入一个链表中，每次取出链表头部的节点即可。
   插入和删除操作的时间复杂度是 O(1)，但查找最近的定时器的时间复杂度是 O(n)，其中 n 是链表中节点的数量，因此不适合定时器数量较多的情况。

2. 二叉搜索树：将所有定时器按照时间顺序插入一个二叉搜索树中，每次取出最小值即可。
  插入、删除和查找操作的时间复杂度都是 O(log n)，其中 n 是树中节点的数量，因此比链表更适合定时器数量较多的情况。

3. 时间轮：将所有定时器按照时间顺序分配到一个时间轮的不同槽中，每次取出当前槽中的定时器即可。
   时间轮的大小是固定的，每个槽的时间跨度相等，因此可以通过简单的计算快速找到当前槽。
   时间轮的插入、删除和查找操作的时间复杂度都是 O(1)，因此非常适合高并发的定时器场景。

总之，选择哪种数据结构实现定时器，需要根据具体的应用场景和需求来决定。
小根堆是最常见的一种实现方式，但其他数据结构也可以在特定的场景中发挥更好的性能。